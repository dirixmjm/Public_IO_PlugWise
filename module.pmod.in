// -*- Pike -*-
// Copyright (c) 2009-2011, Marc Dirix, The Netherlands.
//                         <marc@dirix.nu>
//
// This script is open source software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2, or (at your option) any
// later version.
//
// This module implements a way to interconnect pike with PlugWise modules.
// The module was not written by Plugwise B.V. nor are there any connections 
// between the author and Plugwise B.V. 

#pike __REAL_VERSION__
constant __version="1.0";
constant __author="Marc Dirix <marc@dirix.nu>";
constant __components=({"Public.pmod/IO.pmod/PlugWise.pmod"});


protected class _Stick
{


#define HEAD "\5\5\3\3"
#define FOOT "\r\n"
#define PW_PROTOCOL_DEBUG
#define PPW_PROTOCOL_DEBUG_LOW
#define RESEND 1
#define COMMANDTIMEOUT 1
#define ACKTIMEOUT 5

protected Thread.Mutex lock;
protected Stdio.File sock = Stdio.File();
protected int blocking = 1;
object CirclePlus;
protected string StickMac="";

mapping Plugs = ([]);
mapping Plug_Callbacks = ([]);

protected string receive_buffer="";



void create( string port, int|void non_blocking )
{

   if( non_blocking ) 
      blocking = 0;

   if(!sock->open(port,"rw"))
      error("Can't open port %s\n",port);

   if(!sock->tcsetattr(
   ([ 
"BRKINT": 0,"CLOCAL": 1,"CREAD": 1,"CRTSCTS": 0,  "CSTOPB": 0,  "ECHO": 0,  "ECHOCTL": 0,  "ECHOE": 0,  "ECHOK": 0,  "ECHOKE": 0,  "ECHONL": 0,  "ECHOPRT": 0,  "FLUSHO": 0,  "HUPCL": 1,  "ICANON": 0,  "ICRNL": 0,  "IGNBRK": 0,  "IGNCR": 0,  "IGNPAR": 1,  "IMAXBEL": 0,  "INLCR": 0,  "INPCK": 0,  "ISIG": 0,  "ISTRIP": 0,  "IUCLC": 0,  "IXANY": 0,  "IXOFF": 0,  "IXON": 0,  "NOFLSH": 0,  "OCRNL": 0,  "OFDEL": 0,  "OFILL": 0,  "OLCUC": 0,  "ONLCR": 0,  "ONLRET": 0,  "ONOCR": 0,  "OPOST": 0,  "PARENB": 0,  "PARMRK": 0,  "PARODD": 0,  "PENDIN": 0,  "TOSTOP": 0,  "VDISCARD": 15,  "VEOF": 4,  "VEOL": 0,  "VEOL2": 0,  "VERASE": 127,  "VINTR": 3,  "VKILL": 21,  "VLNEXT": 22,  "VMIN": 1,  "VQUIT": 28,  "VREPRINT": 18,  "VSTART": 17,  "VSTOP": 19,  "VSUSP": 26,  "VSWTC": 0,  "VTIME": 10,  "VWERASE": 23,  "XCASE": 0,  "columns": 0,  "csize": 8,  "columns": 0,  "csize": 8,  "ispeed": 115200,  "ospeed": 115200,  "rows": 0      
   ])
      ))
   {
      error("Failed to initialize serial port\n");
   }
   if( non_blocking ) 
   {
      blocking = 0;
      sock->set_nonblocking(low_answer,0,0);
      call_out(send_command,0,"",10);
   }

   //INIT USB Stick
}

void find_plugs()
{
   call_out(send_command,0,"",8);
}


void set_plug_receive_callback( string macaddress, function callback )
{
   Plug_Callbacks += ([ macaddress: callback ]);
}

void low_answer( mixed id, string message )
{
   receive_buffer+=message;

   //Find newline in the buffer
   int bufferpointer = search(receive_buffer,"\n");
   while( bufferpointer > 0 )
   {
      string line = receive_buffer[..bufferpointer-1 ];
      receive_buffer=receive_buffer[bufferpointer+1..];
      bufferpointer = search(receive_buffer,"\n");

      if(has_prefix( line, "\203" ))
         line = line[1..];
      if(has_suffix( line, "\r" ) )
         line -= "\r"; 
      
      //The stick sends data that we don't use.
      if(!has_prefix(line, HEAD) )
         continue;

      //Remove the HEAD
      line = line[4..];
#ifdef PW_PROTOCOL_DEBUG_LOW
      werror("%O\n",line);
#endif
      //FIXME is there a better check if it is a message or an ACK?
      int command=0;
      sscanf(line,"%4x",command);
      if( command == 0 )
      {
         werror("Line %O\n",line);
         //ACK Check it
      }
      else 
      {
         //COMMAND CALLOUT?
         seperate_data(line);
      }
   }
}

void seperate_data( string message ) 
{
   int crc=0;
   //Set the stringpointer on the end of the first command.
   int command = -1;
   sscanf(message[..3],"%4x",command);
   //FIXME Error?
   if( command == -1 )
      return;
   string commandcounter = message[4..7];
   //FIXME command2
   string macaddr = message[8..23];
   string payload = message[24..(strlen(message)-5)];
   //Extract CRC
   sscanf(message[(strlen(message)-4)..],"%4x",crc);
   if ( crc != Public.Crypto.CRC.CRC16X()->calcstring(message[..(strlen(message)-5)]))
   {
      //FIXME Error Callback?
#ifdef PW_PROTOCOL_DEBUG
      werror("CRC Checksum failed on received data\n");
#endif
      pendingcommand->time=0;
      low_send();
      return;
   }
#ifdef PW_PROTOCOL_DEBUG
      werror("Received: %O\n",message);
#endif
   //FIXME call_out, if non-blocking?
   receive_callback(macaddr, command, payload);

   //Answer received, reset the command timer and send next command
   pendingcommand->time=0;
   low_send();
}

mapping pendingcommand = ([]);
array transmitqueue = ({});

void send_command( string macaddress, string|int request, string|void data)
{
   string req = stringp(request)?request:sprintf("%04X",request);
   transmitqueue += ({ ([ "mac": macaddress, "request":req, "data": data?data:"" ]) });
   low_send();
}

void low_send()
{
   //Check if another command is pending.
   if( pendingcommand->time > time() )
   {
      return;
   }

   remove_call_out(receive_timeout);
   //Check if another command is queued
   if( !sizeof( transmitqueue ) )
   {
      return;
   }

   //pop command from queue
   string request = transmitqueue[0]->request;
   string payload = transmitqueue[0]->data;
   string macaddress = transmitqueue[0]->mac;
   pendingcommand = transmitqueue[0] + ([ "time": time() + COMMANDTIMEOUT ]);

   //Start the next command in case the plug is offline
   werror("%O\n",pendingcommand);
   transmitqueue = transmitqueue[1..];

#ifdef PW_PROTOCOL_DEBUG
   write("Send: %O\n", request + macaddress + payload +
               sprintf("%04X",Public.Crypto.CRC.CRC16X()->calcstring(
                                             request+macaddress+payload)));
#endif

   sock->write(HEAD + request + macaddress + payload +
               sprintf("%04X",Public.Crypto.CRC.CRC16X()->calcstring(
                                        request+macaddress+payload))+ FOOT);

   //FIXME if ACK fails do next command.
   if( ! blocking ) 
   {
      call_out( receive_timeout, COMMANDTIMEOUT );
      if( sizeof(receive_buffer) )
      {
         call_out(low_answer,0,0,"");
      }
   }
  /*
   else if ( commandcount )
      wait_answer( commandcount );
  */
}

void close()
{
   remove_call_out(receive_timeout);
   remove_call_out(send_command);
   sock->close();
}

protected void receive_timeout( )
{
#ifdef PW_PROTOCOL_DEBUG
   werror("Receive Timeout for Plug: %s\n",pendingcommand->mac);
#endif
   pendingcommand->time = 0;
   Plugs[pendingcommand->mac]->offline();
   //Send next command
   low_send();
}


protected void receive_callback( string mac, int command, string data )
{
   switch(command)
   {
      case 0:
         werror("Isn't this an acknowledge? %d\n",command);
      break;
      //A device wants to join?
      case 6:
      {
         send_command(mac, 7, "");
         if( ! has_index( Plugs, mac ) )
         {
            Plugs[mac]= _Plug(mac, this, 0 );
         }
         else
         {
            Plugs[mac]->info();
         }
      }
      break;
      case 17:
         //Stick Init Return Command, contains Stick Mac, Circle+ Mac
         StickMac = mac;
         string maccircleplus;
         sscanf(data,"%6*s%14s%*s",maccircleplus);
         maccircleplus = "00" + maccircleplus;
         CirclePlus = _Plug(maccircleplus, this, 1);
         //CirclePlus->find_plugs();
         Plugs[ maccircleplus] = CirclePlus;
         break;
      //FIXME Is it reasonable to catch this at this level, or
      //should the circleplus get the data
      case 25:
         sscanf(data,"%16s%*s",string maccircle);
         if( has_prefix(maccircle, "F") )
            break;
         Plugs[maccircle]= _Plug(maccircle, this, 0 );
         break;
      default:
         if( mac == StickMac )
         {
            werror("Received data for Unknown Command %d for Stick\n", command);
            werror("Data %O\n",data);
         }
         if( !has_index( Plugs, mac ) )
         {
            werror("Received data for Unknown Plug: %s\n",mac);
            werror("Command %d Data %O\n",command,data);
            return;
         }
         Plug_Callbacks[mac](command, data);
   }
}
}

_Stick `()(string port, int|void non_blocking ) 
{
   return _Stick( port, non_blocking );
}

protected class _Plug
{
protected object Stick;
protected string mac;
protected int circleplus = 0;
protected float gain_a=0.0,gain_b=0.0,offtot=0.0,offnoise=0.0;

int netfrequency =  0;
int powerstate = 0;
int builddate = 0;
int online = 0;
protected int plugtime = 0;
protected int lasttime = 0;

protected float pulse;

string hwversion="";
protected int logclock = 0;
//Pointerr to the address of the current powerlog
protected int logpointer = 0;
//Address of the last powerlog
int logaddress = 0;
protected array last_powerlog = ({});
protected function powerlog_callback = 0;

void close()
{
   destruct(this);
}

//! Connect to a Plug in the PlugWise network.
//! Plugs have to be added to the network using the 
//! Microsoft windows tool provide by PlugWise B.V.
//! The Source.
//! 
//! @param port
//! The Protocol object returned from
//! earlier instantations of this PlugWise Network
//! make sure to reuse the Protocol object if possible
//! @param macaddress
//! The mac address of the plug, either the 5 byte, 6 byte or
//! full 16 byte mac works.
void create(string macaddress, object _stick, int|void plus)
{
   mac = macaddress;
   Stick = _stick;
   Stick->set_plug_receive_callback( macaddress, receive_callback );
   info();
   power_calibrate();
   circleplus=plus;
   if( plus )
      find_plugs();   
}

protected int YMMtoUnix(string YMM)
{
   //Format is Year_Month_MonthMinute
   int year, month, minutes;
   sscanf(YMM,"%2x%2x%4x",year,month,minutes);
   year+=2000;
   if(!month ||  month > 12 )
      return 0;
   return Calendar.Year(year)->set_timezone("GMT")->month(month)->minute(minutes)->unix_time();

}

protected void power_calibrate()
{
   Stick->send_command(mac, 38 );
   //sscanf(String.hex2string(data),"%4F%4F%4F%4F",gain_a,gain_b,offtot,offnoise);
}

//! Retrieve the plug current clock in unix time.
//! @param sync
//! synchronize clock before returning
void clock( )
{
   string data = Stick->send_command(mac, 62, "" );
}

void offline()
{
   pulse = 0.0;
   online = 0;
}
   
//! Refresh the Plug info. No data is returned here, only the internal
//! representation of the Plug status like online,powerstate,time
//! net frequency and hardware version are recollected from the plug.
void info()
{
   Stick->send_command(mac, 35 );
} 

//! Test command
void test( int command, string|void extra )
{

   Stick->send_command(mac, command, stringp(extra)?extra:"" );

}

//! Check if the Circle Is Registered
//!
void isregistered( string reg_mac )
{
   Stick->send_command(mac, 28, reg_mac);
}
  
protected float pulse_correction(int pulse, int timespan)
{
   float pulses = pulse *1.0 / timespan;
   pulses = (timespan * (((pow(pulses / 1.0 + offnoise, 2.0) * gain_b) + 
                    ((pulses / 1.0 + offnoise) * gain_a)) + offtot));
   //return (pulses<0)?0.0:pulses;
   return pulses;
}

protected float pulse_to_watt(float pulse)
{
   return pulse * 1000/468.9385193;
}
   
protected float pulse_to_kwh(float pulse)
{
   return pulse /3600 /468.9385193;
}
 
//! Returns the logged power load on the plug.
//! The load on the plug is logged per hour in sets of four. 
//! Each log entry contains the total Pulses in the hour, so 
//! in order to get the power use the formula:
//! Pulses / 3600 / 468.9385193
//!
//! @param addr
//! the logaddress  which needs to be queried. The current logaddress
//! is Plug->logaddress. This however points to the current not completed 
//! log.
//! @param callback
//! This function is called when the power log is returned from the plug
//! @returns 
//! a  is returned containing 4 one-hour logs. 
//! These must not be consecutive. Each mapping contains the 
//! unix time and the number of pulses.
array powerlog( int|void addr)
{
   //info();
   int log = zero_type(addr)?logpointer:addr;
   Stick->send_command(mac, 72,sprintf("%08X",(log*32+278528)));
   return last_powerlog;
} 

int powerlogpointer()
{
   info();
   return logpointer;
}

void set_powerlog_callback( function callback )
{
   powerlog_callback = callback;
}

void remove_powerlog_callback()
{
   powerlog_callback = 0;
}

//! Find other Plugs in the Network
//! Keep in mind this only works for the Circle+
//!
//! @returns
//! array containing all found plugs. If non are found, or the plug is
//! not a Circle+ an empty array is returned. 
void find_plugs()
{
   if(!circleplus)
      return;

   int count;
   array res=({});
   for(count = 0; count <= 0x3F; count++)
   {
//         string data = Stick->send_command(mac, 24,sprintf("%02X",count));
      Stick->send_command(mac, 24,sprintf("%02X",count));
   }
} 

//! Switches the plug on.
//! info() is called internally, to update the state. No acknowledge 
//! is provided.
void on()
{
   Stick->send_command(mac,23, "01");
   //Update info
   info();
}

//! Switches the plug off.
//! info() is called internally, to update the state. 
//! No acknowledge is provided.
void off()
{
   Stick->send_command(mac, 23, "00");
   //Update info
   info();
}

protected void receive_callback(int command, string data )
{
   //FIXME How do I detect if a plug goes offline?
   online=1;
   switch( command )
   {
   case 19:
   {
      int val=0,val1=0;
      sscanf(data,"%04x%04x",val,val1);
      pulse = pulse_correction(val, 1);
      break;
   }
   //return code from info() command.
   case 29:
      werror("Received 001D with %O\n",data);
      break;
   case 36:
   {
      //FIXME First bytes should return some date info, but not for my plug.
      logclock = YMMtoUnix(data[0..7]);
      sscanf(data[8..15],"%x",logpointer);
      logpointer= (logpointer - 278528 ) / 32;
      switch(data[16..17])
      {
      case "01":
         powerstate=1;
         break;
      case "00":
         powerstate=0;
      }
      switch(data[18..19])
      {
      case "85":
         netfrequency=50;
         break;
      case "C5":
         netfrequency=60;
         break;
      default:
         netfrequency=0;
      }
      hwversion=data[20..31];
      sscanf(data[32..37],"%x",builddate);
      clock();
   }
   break;
   case 39:
      sscanf(String.hex2string(data),"%4F%4F%4F%4F",gain_a,gain_b,offtot,offnoise);
   break;
   case 58:
   {
      int hour,minute,second,dow,dom,month,year;
      sscanf(data,"%2d%2d%2d%2d%2d%2d%2d",second,minute,hour,dow,dom,month,year);
      plugtime = Calendar.parse("%s-%m-%h-%e-%D-%M-%y",sprintf("%02d-%02d-%02d-%02d-%02d-%02d-%02d",second,minute,hour,dow,dom,month,year))->unix_time();;
#ifdef PW_PROTOCOL_DEBUG
      write("Plug Time: %d %d\n",plugtime,time(1)); 
#endif
   }
   break;
   case 63:
   {
      //I Suspect this is a logvalue for the software to set the last log-time.   
      int hour,minute,second,dow;
      sscanf(data[..7],"%2x%2x%2x%2x",hour,minute,second,dow);
      lasttime = Calendar.Second("unix", logclock)->set_timezone("GMT")->day()->hour(hour)->minute(minute)->second(second)->unix_time();
#ifdef PW_PROTOCOL_DEBUG
      write("Plug Time: %d %d\n",plugtime,time(1)); 
#endif
      /*
      if(abs(plugtime-time(1)) >= 60 )
      {
         mapping cdate = Calendar.now()->set_timezone("GMT")->datetime();
         int yr = cdate->year-2000;
         int month_minute = (cdate->day-1)*24*60+cdate->hour*60+cdate->minute;
         string towrite = sprintf("%02X%02X%04XFFFFFFFF%02X%02X%02X%02X",
                                  yr,cdate->month,month_minute,
                                  cdate->hour,cdate->minute,cdate->second,
                                  cdate->week_day);
         string data = Stick->send_command(mac, 22, towrite);
         //Re-read the plug clock
         info();
         clock();
      }
      */
   }
   break;
   case 73:
      array x = array_sscanf(data,"%8s%8x%8s%8x%8s%8x%8s%8x%8x");
      int logaddress = (x[8] - 278528) / 32;
      array last_powerlog = ({ ([ "hour":YMMtoUnix(x[0]),"pulses":pulse_correction(x[1],3600), "kwh": pulse_to_kwh(pulse_correction(x[3],3600)) ]), 
             ([ "hour":YMMtoUnix(x[2]),"pulses":pulse_correction(x[3],3600), "kwh": pulse_to_kwh(pulse_correction(x[3],3600) ) ]), 
             ([ "hour":YMMtoUnix(x[4]),"pulses":pulse_correction(x[5],3600), "kwh": pulse_to_kwh(pulse_correction(x[5],3600) ) ]), 
             ([ "hour":YMMtoUnix(x[6]),"pulses":pulse_correction(x[7],3600), "kwh": pulse_to_kwh(pulse_correction(x[7],3600) ) ]) });
      if( powerlog_callback )
         powerlog_callback( last_powerlog, logaddress );
      break;
      default:
         werror("Received Unknown Command %d\n",command);
         werror("Data %s\n",data);
   }
}

//! Returns the current powerload off the plug. 
//! in nonblocking mode the last known value is returned.
//! @param pulses
//! when non-zero power returns the information in Pulses otherwise in Watt.
//!  Watt = Pulses * 1000 / 468.9385193
//! @returns
//! powerload in Pulses or Watt
float power( int|void pulses )
{
      Stick->send_command(mac, 18 );
      return pulses?pulse:pulse_to_watt(pulse);
}
}
